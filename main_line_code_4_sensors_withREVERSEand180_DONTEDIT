// -----MOTOR INITILIASATION-------
#include <Adafruit_MotorShield.h>
//initalise motorshield
Adafruit_MotorShield AFMS = Adafruit_MotorShield();
// initalise motors
Adafruit_DCMotor *leftMotor = AFMS.getMotor(3);//M3 pin
Adafruit_DCMotor *rightMotor = AFMS.getMotor(4);//M4 pin
//initalise motor variables
int motorSpeed = 200;//200
int reverseMotorSpeed = 200; //(may need seperate speed callib for reversing)
int steeringMotorSpeed = 180;//180
int turningMotorSpeed = 180;//180
int slowMotorSpeed = 100;//CALIBRATE
int timeLength = 200; // define turning time
bool isMoving = false; // Tracks whether the robot is moving
// ----------------------------------
// -----LED INITILIASATION-------
bool LED = false;
/*
//initalise Led
#define movingLed 1
#define BLUE_LED_PIN 11 // Replace x with the actual pin number for the blue LED
*/
// ----------------------------------
// -----Line Sensor INITILIASATION-------
int left_line_sensor_pin=3; // left line sensor
int right_line_sensor_pin=11; // right line sensor
int front_left_line_sensor_pin =2; // sensor on line at front
int front_right_line_sensor_pin =13; // sensor on line at back
// ----------------------------------
// -----Junction INITILIASATION-------
bool at_T_junction = false;// can only go left or right
bool at_right_T_junction = false;// can only go right or forward
bool at_left_T_junction = false;// can only go left or forward

bool left = false;
bool right = false;
static unsigned long totalMillis = 1000;//needs atleast one second after junction detected before it can be detected again.
unsigned long startMillis = 0;
bool junction_detected = false;

bool turn_left = false;
bool turn_right = false;
bool started_turn_from_left_on_line = false;
bool started_turn_from_right_on_line = false;
bool check_end_turn = false;

// ----------------------------------

// -----Other Vars INITILIASATION-------
bool reverse = false;
bool left_180 = false;//180 turn left
bool right_180 = false;//180 turn right
bool set_next_action = true;
//

void(* resetFunc) (void) = 0; //  function to reset Arduino

void IRS(){
  Serial.println("RESET");//have to reopen serial comms to see.
  resetFunc();
}

void setup() {
  // Start the motor shield
  AFMS.begin();
  // Set initial motor speed to 0
  leftMotor->setSpeed(0);
  rightMotor->setSpeed(0);
  // Initial direction
  leftMotor->run(FORWARD);
  rightMotor->run(FORWARD);
  pinMode(left_line_sensor_pin, INPUT); // initialize Right sensor as an inut
  pinMode(right_line_sensor_pin, INPUT); // initialize Left sensor as as input
  pinMode(front_left_line_sensor_pin, INPUT); // initialize front left sensor as an inut
  pinMode(front_right_line_sensor_pin, INPUT); // initialize front right sensor as as input
  // Initialize Serial Communication at 9600 baud rate
  Serial.begin(9600);
  Serial.println("Start");
  delay(100); // Ensure serial communication is fully set up
  // Additional setup as needed
}
void loop() {
  int left_line_value = digitalRead(left_line_sensor_pin); // read left input value
  int right_line_value = digitalRead(right_line_sensor_pin); // read right input value
  int front_left_line_value = digitalRead(front_left_line_sensor_pin); // read front input value
  int front_right_line_value = digitalRead(front_right_line_sensor_pin); // read front input value
  delay(25);
  
  //// NAVIGATION CODE GOES HERE

  //// actual turning (180 turning set if needed and no forward or backward motion as done on line not on junction)
  if (turn_left == true || left_180 == true){
    //180 degree turn or reverse till junction need on spot.
    if (left_180 == true || reverse == true){
      turnLeftOnSpot();
    }
    else{
      turnLeft();
    }
    
    if (started_turn_from_left_on_line == false && started_turn_from_right_on_line == false && check_end_turn == false){
      if (digitalRead(right_line_sensor_pin) == 1){// also should work for end t-junction
        started_turn_from_right_on_line = true;
        check_end_turn = true;
      }
      else if (digitalRead(left_line_sensor_pin) == 1){
        started_turn_from_left_on_line = true;
      }
      
    }

    //// left turn left on line (needs right to cross line)
    if (started_turn_from_left_on_line == true && check_end_turn == false){
      if (digitalRead(right_line_sensor_pin) == 1){
        check_end_turn = true;
      }
    }
    ////

    //// when both right sensors off line, continue line following
    if (check_end_turn == true){
      if (digitalRead(right_line_sensor_pin) == 0 && digitalRead(front_right_line_sensor_pin) == 1){
        turn_left = false;
        left_180 = false;
        started_turn_from_left_on_line = false;
        started_turn_from_right_on_line = false;
        check_end_turn = false;
        set_next_action = true;
        reverse = false;
        moveForward();//always move forward after turn by default
      }
    }
    ////
  }
  if (turn_right == true || right_180 == true){
    //180 degree turn or reverse till junction need on spot.
    if (right_180 == true  || reverse == true){
      turnRightOnSpot();
    }
    else{
      turnRight();
    }

    if (started_turn_from_left_on_line == false && started_turn_from_right_on_line == false && check_end_turn == false){
      if (digitalRead(left_line_sensor_pin) == 1){// also should encompass t-junction
        started_turn_from_left_on_line = true;
        check_end_turn = true;
      }
      else if (digitalRead(right_line_sensor_pin) == 1){
        started_turn_from_right_on_line = true;
      }
      
    }

    //// right turn right on line (needs left to cross line)
    if (started_turn_from_right_on_line == true && check_end_turn == false){
      if (digitalRead(left_line_sensor_pin) == 1){
        check_end_turn = true;
      }
    }
    ////

    //// when both left sensors off line, continue line following
    if (check_end_turn == true){
      if (digitalRead(left_line_sensor_pin) == 0 && digitalRead(front_left_line_sensor_pin) == 1){
        turn_right = false;
        right_180 = false;
        started_turn_from_left_on_line = false;
        started_turn_from_right_on_line = false;
        check_end_turn = false;
        set_next_action = true;
        reverse = false;
        Serial.println("finished turn");
        moveForward();//always move forward after turn by default
      }
    }
    ////
  }


  
  //e.g., for left detected if passing junction, left veer will happen but then right will cancel, till it leaves junction (hopefully enough for it to not veer off)
  if (front_left_line_value == 1 && front_right_line_value == 0 && turn_left == false && turn_right == false && at_left_T_junction == false){// will not steer left in junction
    if (reverse == true){
      rightABit();// correct in opposite way 
    }
    else{
      leftABit();
    }
  }
  if (front_left_line_value == 0 && front_right_line_value == 1 && turn_left == false && turn_right == false && at_right_T_junction == false){
    if (reverse == true){
      leftABit();//correct in opposite way
    }
    else{
      rightABit();
    }
  }



  

  
  //// sets turning direction
  if (junction_detected == true){//
    Serial.println("Junction detected");
    turn_left = left;
    turn_right = right;
    left = false;
    right = false;
    junction_detected = false;
  }
  ////


  if(front_left_line_value==0 && front_right_line_value==0 && turn_left == false && turn_right == false){ //FORWARD if correct at start
    at_left_T_junction = false;
    at_right_T_junction = false;
    at_T_junction = false;
    //Serial.println("FORWARD");
    if (reverse == true){
      moveBackward();
    }
    else{
      moveForward();
    }
    
  }
  
  //// junctions dependent on route --> i.e., left and right predetermined, junction detected is the purpose of this code
  if (turn_left == false && turn_right == false && junction_detected == false && (millis() - startMillis > totalMillis)){
    if ((left_line_value==1 && right_line_value==1) || (left_line_value==1 && right_line_value==0) || (left_line_value==0 && right_line_value==1)){
      if (left_line_value==1 && right_line_value==1){
        at_T_junction = true;
        junction_detected = true;
      }
      else if (left_line_value==1 && right_line_value==0){
        Serial.println("LEFT");
        at_left_T_junction = true;
        if (left == true){
          junction_detected = true;
        }
        
      }
      if (left_line_value==0 && right_line_value==1){
        Serial.println("RIGHT");
        at_right_T_junction = true;
        if (right == true){
          junction_detected = true;
        }
      }
      


      if (reverse == true){//in next run should detect it
        set_next_action = true;
      }
      // for now always turn right
      right = true;
      //REMOVE as will be set in navigation selection statement.

      startMillis = millis();
    }
    else {
      junction_detected = false;
    }
  }
  ////
}


// DECLARE FUNCTIONS TO MOVE --
void moveForward() {
  //Serial.println("Moving forwards ...");
  isMoving = true; // Start moving
  leftMotor->setSpeed(motorSpeed);
  rightMotor->setSpeed(motorSpeed);
  //leftMotor->run(FORWARD);
  //rightMotor->run(FORWARD);
  leftMotor->run(BACKWARD);
  rightMotor->run(BACKWARD);
}

void moveForwardSlowly() {
  Serial.println("Moving forwards slowly ...");
  isMoving = true; // Start moving
  leftMotor->setSpeed(slowMotorSpeed);
  rightMotor->setSpeed(slowMotorSpeed);
  //leftMotor->run(FORWARD);
  //rightMotor->run(FORWARD);
  leftMotor->run(BACKWARD);
  rightMotor->run(BACKWARD);
}

void stopMoving() {
  Serial.println("Stopping motion ...");
  isMoving = false;
  left = false;
  right = false;
  leftMotor->setSpeed(0);
  rightMotor->setSpeed(0);
  delay(1000);
}

void moveBackward() {
  //Serial.println("Moving forwards ...");
  isMoving = true; // Start moving
  leftMotor->setSpeed(reverseMotorSpeed);
  rightMotor->setSpeed(reverseMotorSpeed);
  //leftMotor->run(FORWARD);
  //rightMotor->run(FORWARD);
  leftMotor->run(FORWARD);
  rightMotor->run(FORWARD);
}

void turnRight() {
  //Serial.println("Turning right ...");
  isMoving = true;
  leftMotor->setSpeed(turningMotorSpeed);
  rightMotor->setSpeed(turningMotorSpeed/2);
  // leftMotor->run(FORWARD);
  // rightMotor->run(BACKWARD);
  leftMotor->run(BACKWARD);
  rightMotor->run(FORWARD);
}
void turnLeft() {
  //Serial.println("Turning left ...");
  isMoving = true;
  leftMotor->setSpeed(turningMotorSpeed/2);
  rightMotor->setSpeed(turningMotorSpeed);
  // leftMotor->run(BACKWARD);
  // rightMotor->run(FORWARD);
  leftMotor->run(FORWARD);
  rightMotor->run(BACKWARD);
}
void turnRightOnSpot() {//useful after reversing or for 180 -- test
  Serial.println("Turning right ON SPOT ...");
  isMoving = true;
  leftMotor->setSpeed(turningMotorSpeed);
  rightMotor->setSpeed(turningMotorSpeed);
  // leftMotor->run(FORWARD);
  // rightMotor->run(BACKWARD);
  leftMotor->run(BACKWARD);
  rightMotor->run(FORWARD);
}
void turnLeftOnSpot() {
  Serial.println("Turning left ON SPOT ...");
  isMoving = true;
  leftMotor->setSpeed(turningMotorSpeed);
  rightMotor->setSpeed(turningMotorSpeed);
  // leftMotor->run(BACKWARD);
  // rightMotor->run(FORWARD);
  leftMotor->run(FORWARD);
  rightMotor->run(BACKWARD);
}
void leftABit(){
  //Serial.println("left a bit");
  isMoving = true;
  leftMotor->setSpeed(steeringMotorSpeed/5);
  leftMotor->run(BACKWARD);
  rightMotor->setSpeed(steeringMotorSpeed);
  rightMotor->run(BACKWARD);
}
void rightABit(){
  //Serial.println("right a bit");
  isMoving = true;
  rightMotor->setSpeed(steeringMotorSpeed/5);
  rightMotor->run(BACKWARD);
  leftMotor->setSpeed(steeringMotorSpeed+30);// might be good removing + 30
  leftMotor->run(BACKWARD);
}
